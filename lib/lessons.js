var _ = require('underscore'),
    minimatch = require('minimatch'),
    path = require('path'),
    common = require('./common.js'),
    fs = require('fs'),
    jsonfile = require('jsonfile'),
    uuid = require('node-uuid');

module.exports = function(config) {
  return function(files, metalsmith, done) {
    
    lessonDirectories = [];
    _.each(files, function (file, filename) {
      file.is_lesson = minimatch(filename, 'lessons/**/lesson.*');
      if (file.is_lesson) {
        lessonDirectories.push(path.dirname(filename));
      }
    });
    
    var currentLessonIDs = {};
    _.each(files, function (file, filename) {
      containingLessons = _.filter(lessonDirectories, function (prefix) {
        return path.dirname(filename).startsWith(prefix);
      });
      if (containingLessons.length > 1 && file.is_lesson) {
        done(new Error(filename + " is in two lesson subdirectories: " + containingLessons));
      } else if (containingLessons.length == 1) {
        if (file.lesson) {
          done(new Error(filename + " already contains a lesson attribute. It should not."));
        }
        if (!(file.is_lesson)) {
          file.lesson = containingLessons[0];
        } else {
          try {
            file.uuid = JSON.parse(files[path.join(path.dirname(filename), '.uuid.json')].contents).uuid;
            (currentLessonIDs[file.uuid] = currentLessonIDs[file.uuid] || []).push(filename);
          } catch (err) {};
        }
      }
    });

    var previousLessonIDsFile = path.join(metalsmith.source(), 'lessons/.lessons.json');
    previousLessonIDs = {};
    try {
      previousLessonsIDs = JSON.parse(files[previousLessonIDsFile].contents);
      delete(files[previousLessonIDsFile]);
    } catch (err) {};
    
    _.each(currentLessonIDs, function (filenames, uuid) {
      if (filenames.length > 1) {
        var errorText = "Duplicate UUIDs. ";
        if (uuid in previousLessonIDs) {
          previousFilename = previousLessonIDs[uuid];
          if (previousFilename in filenames) {
            errorText += "I've seen this UUID before as " + previousFilename + " Was it copied? ";
            errorText += "If so, please remove .uuid.json from ";
            errorText += _.difference(filenames, [previousFilename]).join(',');
          } else {
            errorText += "I've seen this UUID before as " + previousFilename + " before. Was it moved? ";
            errorText += "The duplicates are in " + filenames.join(',');
          }
        } else {
          errorText += "These are all new. I don't know what to do. ";
          errorText += "The problems are in " + filenames.join(',');
        }
        done(new Error(errorText));
      } else {
        currentLessonIDs[uuid] = filenames[0];
      }
    });

    newLessons = _.pick(common.lessonfiles(files), function (file, filename) {
      return (!('uuid' in file));
    });
    _.each(newLessons, function (file, filename) {
      file.uuid = uuid.v4();
      jsonfile.writeFileSync(path.join(metalsmith.source(), path.dirname(filename), '.uuid.json'), {
        'uuid': file.uuid,
        'note': "This file is autogenerated. " + 
        "It uniquely identifies this lesson. " + 
        "Do not change or delete it. " + 
        "If you move this lesson, move this file along with it. " +
        "Please see src/content/README.adoc for more details."
      });
      currentLessonIDs[file.uuid] = filename;
    });

    if (_.size(newLessons) > 0) {
      console.log("Identified and uniquely labeled " + newLessons.length + " new lesson(s).");
      console.log("New .uuid.json files have been created. " +
          "They should be kept with their lesson.adoc file.");
      console.log("Please see src/content/README.adoc for more details.");
    }
    
    console.log(currentLessonIDs);
    done();
  }
};

// vim: ts=2:sw=2:et
